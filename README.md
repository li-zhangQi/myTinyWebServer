# 对项目的整体梳理

___

>注：
>
>T：变量类型
>
>C：参数
>
>H：函数
>
>Q：其他

___



### locker .h 头文件涉及的函数概要

互斥量：

T：pthread_mutex_t

H：pthread_mutex_init()、pthread_mutex_destroy()、pthread_mutex_lock()、pthread_mutex_unlock()

信号量：

T：sem_t

H：sem_init()、sem_destroy()、sem_wait()、sem_post()

>_wait函数将以原子操作方式将信号量减一，信号量为0时，sem_wait阻塞
>
>_post函数以原子操作方式将信号量加一，信号量大于0时，唤醒调用sem_post的线程

条件变量：

T：pthread_cond_t

H：pthread_cond_init()、pthread_cond_destroy()、pthread_cond_wait()、pthread_cond_timewait()、	

​		pthread_cond_signal()、pthread_cond_broadcast()

>条件变量需要配合锁来使用
>
>_wait等待条件变量时，线程会先释放持有的互斥锁，然后进入阻塞状态，等待其他线程通过条件变量的通知来唤		醒它。在收到通知后，线程会重新获得互斥锁，然后继续执行

### 包含的功能：

1、互斥量、信号量、条件变量的创建

___



### threadpool.h 头文件涉及函数概要

T：pthread_t

H：pthread_creat()、pthread_detach()	

>_creat函数中，通常将线程的入口点函数定义为静态函数，以满足pthread_create函数的要求，并通过传递类实		例的this指针作为参数，实现类成员的访问。如static void *worker(void *arg);

Q： list<T *> m_workqueue //请求队列，注意为指针类型

​		T *request = m_workqueue.front() //从请求队列中取出第一个任务

### 包含的功能：

1、创建线程，通过一个静态成员函数，实现成为工作线程

2、创建请求队列，分别在reactor模式和proactor模式下 通过信号量的通知机制将请求任务放入任务队列

3、创建工作线程的处理函数，函数先获取到线程池对象，通过此对象获取到业务处理函数

4、在业务处理函数中，若为reactor模式则调用处理读写IO事件，如果为读事件则调用循环读取用户数据，来处理请求报		文并报文响应，如果为写事件则调用函数往响应报文写入数据；若为proactor模式则直接调用处理请求报文并报文响		应 完成用户请求而无需负责数据的读写。

### 设计总结：

本线程池的设计模式为半同步/半反应堆，其中反应堆具体为Proactor事件处理模式。

具体的，主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任		务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理。

>proactor事件处理模式中：
>
>- 主线程充当异步线程，负责监听所有socket上的事件
>- 若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件
>- 如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中
>- 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权

___



### block_queue.h头文件涉及函数概要

T：struct timespec、struct timeval

H：gettimeofday()

Q ：m_back = (m_back + 1) % m_max_size;  //m_back + 1为要让出入数据的位置，取模能防止跃出队列位置

​		m_front = (m_front + 1) % m_max_size; //循环队列中，不论进队列还是出队列，尾指针或者头指针都先加1

### 包含的功能：

1、创建一个阻塞队列，利用循环数组实现

2、将异步日志所写的日志内容先存入阻塞队列（生产者）

3、写线程从阻塞队列中取出内容，写入日志。另可利用条件变量的等待时间参数实现等待（消费者）

### 设计总结：

**异步日志**，将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志

**阻塞队列**，将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区

**生产者-消费者模型**，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push消息，消费者线程从缓		冲区中pop消息

___



### log.h头文件涉及函数概要

H：fputs()

>int fputs(const char *str, FILE *stream)函数是标准C库中的一个输出函数，用于将字符串写入到指定的文件流		中。将字符串 str 写入到文件流 stream 中，直到遇到 null 终止符或写入错误。它不会在输出中添加换行		符。如果文件流操作成功，则返回写入的字符数。
>

### 包含的功能：

1、创建一个日志类，私有化其构造函数不让外界创建创建实例

2、创建一个公有的静态方法，在其内部再创建一个生成实例的静态变量

3、函数体内返回该变量的地址，提供给方法调用者获取该实例

4、创建一个获取异步写日志阻塞队列弹出需要处理的任务的方法，并将通过串接受收到的内容，传入到文件地址处

5、创建一个回调函数，等待前公有的静态方法获取调用异步写入日志的方法

6、自定义输出日志的自定义宏

>void write_log(int level, const char *format, ...);	//将输出内容按照标准格式整理
>
>#define LOG_INFO(format, ...) if(条件) {Log::get_instance()->write_log(1, format, ## _VA_ARGS__); 等}

### 设计总结：

**单例模式**，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享

>私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个		公有的静态方法获取该实例。或使用线程安全的静态局部变量实现线程安全懒汉模式

___



### log.cpp 文件涉及函数概要

T：time_t、struct tm、va_list

H：memset()、time() 、localtime()、strrchr()、strcpy()、snprintf()、fopen()、va_start()、vsnprintf()、va_end()、				fflush()、c_str()

>time函数用于获取当前的系统时间（以秒为单位）自1970年1月1日以来的秒数（UNIX时间戳）
>
>localtime函数用于将时间戳转换为本地时间，并返回一个指向 tm结构的指针
>
>snprintf函数将格式化的数据输出到字符串中
>
>vsnprintf函数用于可变参数列表的字符串格式化
>
>c_str 函数返回的是一个指向以 null 结尾的 C 风格字符串的指针，这样就可以在 C 标准库中使用这个字符串。



### 包含的功能：

1、实现日志初始化，判断如果是异步日志则创建一个阻塞队列，同时创建子线程，在其回调函数中处理阻塞队列的日志		输出

2、获取本地时间的拷贝份

3、自定义格式化日志名，根据传入的整个文件名字符串进行分析，若输入的文件名没有/，则直接将时间+文件名作为日		志名；若有/则，将文件名拆分为路径名与日志名

> 需要拆分的情况：
>
>const char *p = strrchr(file_name, '/'); //查找字符最后一次出现的位置，并返回指向该位置的指
>
>strcpy(log_name, p + 1); //指针未移动
>
>strncpy(dir_name, file_name, p - file_name + 1); //p - file_name + 1是文件所在路径文件夹的长度，因为				file_name为数组首地址，指向文件名最后一个/符的 p - file_name + 1 即为路径名

4、将格式化好的日志名作为文件路径，以追加方式打开文件，并将返回的结构体指针赋给成员变量，为后续写入该日志		做准备

5、创建一个写入日志的方法，方法的参数列表为可变参数列表，实现超行、按天分文件的业务逻辑

6、最后将完成的同步日志输入到之前返回的结构体指针指向的的文件；若是异步则将日志加入到阻塞队列等待处理

### 设计总结：

本次使用单例模式创建日志系统，对服务器运行状态、错误信息和访问数据进行记录，该系统可以实现按天分类，超行分		类功能，可以根据实际情况分别使用同步和异步写入两种方式。其中异步写入方式，将生产者-消费者模型封装为阻		塞队列，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。

___

### sql_connection_pool.h 头文件涉及函数概要

T：MYSQL

### 包含的功能：

1、创建数据库连接池的单例模式

2、创建一个获取数据库连接的方法

3、创建一个链表变量存储数据库连接池资源

4、利用RAII机制对数据库连接的获取与释放进行封装，即通过创建RAII类，调用它的内部函数实现连接资源的获取和自		动释放

### 设计总结：

我们使用单例模式和链表创建数据库连接池，实现对数据库连接资源的复用

将数据库连接的获取与释放通过RAII机制封装，避免手动释放

不直接调用获取和释放连接的接口，将数据库连接的获取与释放封装起来，通过RAII机制进行获取和释放

___

### sql_connection_pool.cpp 文件涉及函数概要

H：mysql_init()、mysql_real_connect()、mysql_close()

### 包含的功能：

1、实现通过静态方法内的局部静态变量获取到连接池对象的唯一实例

2、初始化数据库连接池。内部调用mysql的API，使用初始化数据库连接变量方法，使用连接数据库的方法，将连接上的		资源入到数据库连接池队列，统计累计创建出来的空闲连接数。再使用信号量初始化自身为最大连接次数，以此监控		者和消费者对资源的获取情况

3、实现获取数据库连接的方法。使用信号量阻塞等待，同时还要使用互斥锁完成多线程操作连接池的同步操作。当有请		求时，从数据库连接池队列中取出一个可用连接，将其中队列中删除然后返回取出的连接，更新使用和空闲连接数

4、实现释放当前数据库连接的方法（注意不是删除连接）。将传进来的连接重新加入到连接池队列，并通过信号量通知		又产生了一个可用资源

5、实现销毁数据库连接池的方法。通过数据库连接池队列的迭代器对队列里面的每一个数据库连接进行关闭。然后清空		列表

6、实现在RAII的构造函数中，通过参数获取到的对象来调用对象获取一个数据库连接的方法，将获取到的接连变量和连		接池变量统一交由RAII内的变量管理。最后通过RAII的析构函数实现对连接资源的释放。这样就不用手动调用释放资		源	的方法了。实现手动取用RAII，自动释放RAII

### 设计总结：

本次使用单例模式和链表创建数据库连接池，实现对数据库连接资源的复用

系统需要频繁访问数据库时需要频繁创建和断开数据库连接，而创建数据库连接是一个很耗时的操作，也容易对数据库造		成安全隐患。在程序初始化的时候，集中创建多个数据库连接，生成数据库连接池，并把他们集中于此管理，供程序		使用，可以保证较快的数据库读写速度，更加安全可靠

___

### lst_timer.h 头文件涉及函数概要


T：sockaddr_in、time_t

### 包含的功能：

1、利用结构体创建一个封装起来的连接资源，包含套接字地址、文件描述符和定时器

2、创建定时器类，以带头尾结点的升序双向链表为该类的容器。创建前继后继定时器，同时创建一个回调函数等待调用		而管理连接资源

3、创建定时器容器类。创建增加、调整和删除定时器的方法以及定时任务处理的公有方法，但增加和调整都是通过调用		一个添加定时器的私有重载函数来调整定时器的链表内部处理的

4、创建一个工具类。创建对文件描述符的非阻塞设置、注册内核事件表的事件以及信号设置和处理的方法，再创建一个		定时处理任务的方法，不断触发SIGALRM信号

### 设计总结：

本项目中，服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序时间链表容器将所有定		时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务。

> 定时器，利用结构体将多种定时事件进行封装起来。这里只涉及一种定时事件，即定期检测非活跃连接，将该定		事件与连接资源封装为一个结构体定时器
>
> 定时器容器，我们使用升序链表将所有定时器串联组织起来

项目中使用的是SIGALRM信号的定时的方法。利用alarm函数周期性地触发SIGALRM信号，信号处理函数利用管道通知		主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，		释放所占用的资源。

>三种定时方法：
>
>- socket选项SO_RECVTIMEO和SO_SNDTIMEO
>- SIGALRM信号
>- I/O复用系统调用的超时参数

___

### lst_timer.cpp 文件涉及函数概要

T：time_t、epoll_event、struct sigaction

>epoll_event这个结构体类型用来注册文件描述符上的事件，内部有events事件字段和另一个结构体类型data变量		的fd文件描述符字段

C：F_GETFL、F_SETFL、O_NONBLOCK、EPOLLIN、EPOLLET、EPOLLONESHOT、EPOLLRDHUP、                     				SA_RESTART

>EPOLLONESHOT为单次触发模式，在此模式下，一旦文件描述符上有事件到达并被处理，epoll会自动将该文件		描述符从就绪队列中移除，之后该文件描述符将不再被监听。如果希望继续监听该文件描述符上的事件，需		要重新将其加入到epoll的监听队列中。

H：time()、fcntl()、epoll_ctl()、assert()、send()、memset()、sigfillset()、sigaction()、alarm()

>assert函数运行时检查某个条件是否为真，如果为假（即条件不满足）则触发断言错误，终止程序的执行并打印		错误信息
>
>alarm函数设置信号传送闹钟，即用来设置信号SIGALRM在经过特定时间参数后发送给目前的进程。如果未设置		信号SIGALRM的处理函数，那么alarm()默认处理终止进程

### 包含的功能：

1、实现定时器容器类的构造函数和析构函数，注意析构函数即删除循环遍历并删除每一个链表定时器结点

2、实现公有添加定时器的方法。若当前链表中只有头尾结点，直接插入，此时头尾结点都是它；若此定时器超时时间小		于头结点，则将其更新为头结点；若上述都不是，则调用添加定时器的私有重载函数实现结点的位置调整

3、实现调整定时器的方法。任务发生变化时，调整已有定时器在链表中的位置。若被调整的目标定时器在尾部，或定时		器新的超时值仍然小于下一个定时器的超时，不用调整；若被调整定时器是链表头结点，先安排下一个结点为头节		点，将定时器取出重新插入，注意为调用添加定时器的私有重载函数实现结点的位置调整；若被调整定时器在内部，		将定时器取出重新插入，注意取出过程为双向链表的删除结点操作，然后添加定时器的私有重载函数实现被取出结点		与它后面的节点进行比较调整

4、实现定时器结点的删除。注意要删除的结点在头尾中部的不同情况

5、实现定时任务处理方法。获取当前时间戳，与从头循环定时器的超时时间进行比较，若当前时间还未到即小于定时器		的超时时间时，则不用处理，继续遍历；若检测到定时器到期，则调用这个定时器的回调函数并传入封装好的连接资		源去执行定时事件即释放资源，将处理后的定时器从链表容器中删除，并重置下一个结点称为头结点

6、实现私有重载实现定时器在链表内部即非头尾的真正调整函数。若非尾结点则循环比较被取出的定时器的超时时间与		链表头部或被取出的定时器的下一个结点被作为的头部 的下一个结点的超时时间进行比较，若小于头部的下一个结		点，则将其插入到此结点的前面。注意循环时，指针要迭代

7、实现定时器工具类的最小时间间隔的初始化

8、实现对文件描述符设置非阻塞的方法。设置完后返回旧的文件描述符的标志属性

9、实现将读事件在内核事件表的注册。先设定基础读和读端终端的事件，按情况再加上ET触发模式和EPOLLONESHOT		触发模式，将设定好的事件注册到内核事件表中。再将文件描述符设置为非阻塞

10、实现信号处理函数。为保证函数的可重入性，保留原来的错误号。然后按字符字节流的方式将数值信号转为单个字符			形式表达写入到管道的读端。将之前保存错误号重新设置给错误号变量。注意信号处理函数中仅仅发送信号值，不			做对应逻辑处理

11、实现一个信号设置的函数。函数接收信号处理函数作为参数，先创建一个用于设置信号处理的结构体变量，将其里面			可能的值都清空，将传进来的参数作为信号集的处理参数，并按情况设置使被信号打断的系统调用自动重新发起。			再将所有信号加入到阻塞信号集。然后对指定信号进行捕捉交给信号处理函数处理

12、实现定时器处理的函数。调用定时任务处理函数，将要执行的任务进行执行或删除某些过期任务。然后调用闹钟函数			开始计算下次定时器处理时间

13、实现定时器回调函数。从内核事件表中删除非活动连接，关闭文件描述符，释放连接资源。网页客户端连接数减一

### 设计总结：

**信号通知流程**，Linux下的信号采用的异步处理机制，信号处理函数和当前进程是两条不同的执行路线。具体的，当进程		收到信号时，操作系统会中断进程当前的正常流程，转而进入信号处理函数执行操作，完成后再返回中断的地方继续		执行。

​		为避免信号竞态现象发生，信号处理期间系统不会再次触发它。所以，为确保该信号不被屏蔽太久，信号处理函数需				要尽可能快地执行完毕。





