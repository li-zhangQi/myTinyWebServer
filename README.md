# 对项目的整体梳理

___

>注：
>
>T：变量类型
>
>C：参数
>
>H：函数
>
>Q：其他

___



### locker .h 头文件涉及的函数概要

互斥量：

T：pthread_mutex_t

H：pthread_mutex_init()、pthread_mutex_destroy()、pthread_mutex_lock()、pthread_mutex_unlock()

信号量：

T：sem_t

H：sem_init()、sem_destroy()、sem_wait()、sem_post()

>_wait函数将以原子操作方式将信号量减一，信号量为0时，sem_wait阻塞
>
>_post函数以原子操作方式将信号量加一，信号量大于0时，唤醒调用sem_post的线程

条件变量：

T：pthread_cond_t

H：pthread_cond_init()、pthread_cond_destroy()、pthread_cond_wait()、pthread_cond_timewait()、	

​		pthread_cond_signal()、pthread_cond_broadcast()

>条件变量需要配合锁来使用
>
>_wait等待条件变量时，线程会先释放持有的互斥锁，然后进入阻塞状态，等待其他线程通过条件变量的通知来唤		醒它。在收到通知后，线程会重新获得互斥锁，然后继续执行

### 包含的功能：

1、互斥量、信号量、条件变量的创建

___



### threadpool.h 头文件涉及函数概要

T：pthread_t

H：pthread_creat()、pthread_detach()	

>_creat函数中，通常将线程的入口点函数定义为静态函数，以满足pthread_create函数的要求，并通过传递类实		例的this指针作为参数，实现类成员的访问。如static void *worker(void *arg);

Q： list<T *> m_workqueue //请求队列，注意为指针类型

​		T *request = m_workqueue.front() //从请求队列中取出第一个任务

### 包含的功能：

1、创建线程，通过一个静态成员函数，实现成为工作线程

2、创建请求队列，分别在reactor模式和proactor模式下 通过信号量的通知机制将请求任务放入任务队列

3、创建工作线程的处理函数，函数先获取到线程池对象，通过此对象获取到业务处理函数

4、在业务处理函数中，若为reactor模式则调用处理读写IO事件，如果为读事件则调用循环读取用户数据，来处理请求报		文并报文响应，如果为写事件则调用函数往响应报文写入数据；若为proactor模式则直接调用处理请求报文并报文响		应 完成用户请求而无需负责数据的读写。

### 设计总结：

本线程池的设计模式为半同步/半反应堆，其中反应堆具体为Proactor事件处理模式。

具体的，主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任		务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理。

>proactor事件处理模式中：
>
>- 主线程充当异步线程，负责监听所有socket上的事件
>- 若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件
>- 如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中
>- 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权

___



### block_queue.h头文件涉及函数概要

T：struct timespec、struct timeval

H：gettimeofday()

Q ：m_back = (m_back + 1) % m_max_size;  //m_back + 1为要让出入数据的位置，取模能防止跃出队列位置

​		m_front = (m_front + 1) % m_max_size; //循环队列中，不论进队列还是出队列，尾指针或者头指针都先加1

### 包含的功能：

1、创建一个阻塞队列，利用循环数组实现

2、将异步日志所写的日志内容先存入阻塞队列（生产者）

3、写线程从阻塞队列中取出内容，写入日志。另可利用条件变量的等待时间参数实现等待（消费者）

### 设计总结：

**异步日志**，将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志

**阻塞队列**，将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区

**生产者-消费者模型**，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push消息，消费者线程从缓		冲区中pop消息

___



### log.h头文件涉及函数概要

H：fputs()

>int fputs(const char *str, FILE *stream)函数是标准C库中的一个输出函数，用于将字符串写入到指定的文件流		中。将字符串 str 写入到文件流 stream 中，直到遇到 null 终止符或写入错误。它不会在输出中添加换行		符。如果文件流操作成功，则返回写入的字符数。
>

### 包含的功能：

1、创建一个日志类，私有化其构造函数不让外界创建创建实例

2、创建一个公有的静态方法，在其内部再创建一个生成实例的静态变量

3、函数体内返回该变量的地址，提供给方法调用者获取该实例

4、创建一个获取异步写日志阻塞队列弹出需要处理的任务的方法，并将通过串接受收到的内容，传入到文件地址处

5、创建一个回调函数，等待前公有的静态方法获取调用异步写入日志的方法

6、自定义输出日志的自定义宏

>void write_log(int level, const char *format, ...);	//将输出内容按照标准格式整理
>
>#define LOG_INFO(format, ...) if(条件) {Log::get_instance()->write_log(1, format, ## _VA_ARGS__); 等}

### 设计总结：

**单例模式**，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享

>私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个		公有的静态方法获取该实例。或使用线程安全的静态局部变量实现线程安全懒汉模式

___



### log.cpp 文件涉及函数概要

T：time_t、struct tm、va_list

H：memset()、time() 、localtime()、strrchr()、strcpy()、snprintf()、fopen()、va_start()、vsnprintf()、va_end()、				fflush()、c_str()

>time函数用于获取当前的系统时间（以秒为单位）自1970年1月1日以来的秒数（UNIX时间戳）
>
>localtime函数用于将时间戳转换为本地时间，并返回一个指向 tm结构的指针
>
>snprintf函数将格式化的数据输出到字符串中
>
>vsnprintf函数用于可变参数列表的字符串格式化
>
>c_str 函数返回的是一个指向以 null 结尾的 C 风格字符串的指针，这样就可以在 C 标准库中使用这个字符串。



### 包含的功能：

1、实现日志初始化，判断如果是异步日志则创建一个阻塞队列，同时创建子线程，在其回调函数中处理阻塞队列的日志		输出

2、获取本地时间的拷贝份

3、自定义格式化日志名，根据传入的整个文件名字符串进行分析，若输入的文件名没有/，则直接将时间+文件名作为日		志名；若有/则，将文件名拆分为路径名与日志名

> 需要拆分的情况：
>
>const char *p = strrchr(file_name, '/'); //查找字符最后一次出现的位置，并返回指向该位置的指
>
>strcpy(log_name, p + 1); //指针未移动
>
>strncpy(dir_name, file_name, p - file_name + 1); //p - file_name + 1是文件所在路径文件夹的长度，因为				file_name为数组首地址，指向文件名最后一个/符的 p - file_name + 1 即为路径名

4、将格式化好的日志名作为文件路径，以追加方式打开文件，并将返回的结构体指针赋给成员变量，为后续写入该日志		做准备

5、创建一个写入日志的方法，方法的参数列表为可变参数列表，实现超行、按天分文件的业务逻辑

6、最后将完成的同步日志输入到之前返回的结构体指针指向的的文件；若是异步则将日志加入到阻塞队列等待处理

### 设计总结：

本次使用单例模式创建日志系统，对服务器运行状态、错误信息和访问数据进行记录，该系统可以实现按天分类，超行分		类功能，可以根据实际情况分别使用同步和异步写入两种方式。其中异步写入方式，将生产者-消费者模型封装为阻		塞队列，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。

___

### sql_connection_pool.h 头文件涉及函数概要

T：MYSQL

### 包含的功能：

1、创建数据库连接池的单例模式

2、创建一个获取数据库连接的方法

3、创建一个链表变量存储数据库连接池资源

4、利用RAII机制对数据库连接的获取与释放进行封装，即通过创建RAII类，调用它的内部函数实现连接资源的获取和自		动释放

### 设计总结：

我们使用单例模式和链表创建数据库连接池，实现对数据库连接资源的复用

将数据库连接的获取与释放通过RAII机制封装，避免手动释放

不直接调用获取和释放连接的接口，将数据库连接的获取与释放封装起来，通过RAII机制进行获取和释放

___

### sql_connection_pool.cpp 文件涉及函数概要

H：mysql_init()、mysql_real_connect()、mysql_close()

### 包含的功能：

1、实现通过静态方法内的局部静态变量获取到连接池对象的唯一实例

2、初始化数据库连接池。内部调用mysql的API，使用初始化数据库连接变量方法，使用连接数据库的方法，将连接上的		资源入到数据库连接池队列，统计累计创建出来的空闲连接数。再使用信号量初始化自身为最大连接次数，以此监控		者和消费者对资源的获取情况

3、实现获取数据库连接的方法。使用信号量阻塞等待，同时还要使用互斥锁完成多线程操作连接池的同步操作。当有请		求时，从数据库连接池队列中取出一个可用连接，将其中队列中删除然后返回取出的连接，更新使用和空闲连接数

4、实现释放当前数据库连接的方法（注意不是删除连接）。将传进来的连接重新加入到连接池队列，并通过信号量通知		又产生了一个可用资源

5、实现销毁数据库连接池的方法。通过数据库连接池队列的迭代器对队列里面的每一个数据库连接进行关闭。然后清空		列表

6、实现在RAII的构造函数中，通过参数获取到的对象来调用对象获取一个数据库连接的方法，将获取到的接连变量和连		接池变量统一交由RAII内的变量管理。最后通过RAII的析构函数实现对连接资源的释放。这样就不用手动调用释放资		源	的方法了。实现手动取用RAII，自动释放RAII

### 设计总结：

本次使用单例模式和链表创建数据库连接池，实现对数据库连接资源的复用

系统需要频繁访问数据库时需要频繁创建和断开数据库连接，而创建数据库连接是一个很耗时的操作，也容易对数据库造		成安全隐患。在程序初始化的时候，集中创建多个数据库连接，生成数据库连接池，并把他们集中于此管理，供程序		使用，可以保证较快的数据库读写速度，更加安全可靠



