# 对项目的整体梳理

___

>注：
>
>T：变量类型
>
>C：参数
>
>H：函数
>
>Q：其他

___



### locker .h 头文件涉及的函数概要

互斥量：

T：pthread_mutex_t

H：pthread_mutex_init()、pthread_mutex_destroy()、pthread_mutex_lock()、pthread_mutex_unlock()

信号量：

T：sem_t

H：sem_init()、sem_destroy()、sem_wait()、sem_post()

>_wait函数将以原子操作方式将信号量减一，信号量为0时，sem_wait阻塞
>
>_post函数以原子操作方式将信号量加一，信号量大于0时，唤醒调用sem_post的线程

条件变量：

T：pthread_cond_t

H：pthread_cond_init()、pthread_cond_destroy()、pthread_cond_wait()、pthread_cond_timewait()、	

​		pthread_cond_signal()、pthread_cond_broadcast()

>条件变量需要配合锁来使用
>
>_wait等待条件变量时，线程会先释放持有的互斥锁，然后进入阻塞状态，等待其他线程通过条件变量的通知来唤		醒它。在收到通知后，线程会重新获得互斥锁，然后继续执行

### 包含的功能：

1、互斥量、信号量、条件变量的创建

___



### threadpool.h 头文件涉及函数概要

T：pthread_t

H：pthread_creat()、pthread_detach()	

>_creat函数中，通常将线程的入口点函数定义为静态函数，以满足pthread_create函数的要求，并通过传递类实		例的this指针作为参数，实现类成员的访问。如static void *worker(void *arg);

Q： list<T *> m_workqueue //请求队列，注意为指针类型

​		T *request = m_workqueue.front() //从请求队列中取出第一个任务

### 包含的功能：

1、创建线程，通过一个静态成员函数，实现成为工作线程

2、创建请求队列，分别在reactor模式和proactor模式下 通过信号量的通知机制将请求任务放入任务队列

3、创建工作线程的处理函数，函数先获取到线程池对象，通过此对象获取到业务处理函数

4、在业务处理函数中，若为reactor模式则调用处理读写IO事件，如果为读事件则调用循环读取用户数据，来处理请求报		文并报文响应，如果为写事件则调用函数往响应报文写入数据；若为proactor模式则直接调用处理请求报文并报文响		应 完成用户请求而无需负责数据的读写。

### 设计总结：

本线程池的设计模式为半同步/半反应堆，其中反应堆具体为Proactor事件处理模式。

具体的，主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理。

>proactor事件处理模式中：
>
>- 主线程充当异步线程，负责监听所有socket上的事件
>- 若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件
>- 如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中
>- 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权

___



### block_queue.h头文件涉及函数概要

T：struct timespec、struct timeval

H：gettimeofday()

Q ：m_back = (m_back + 1) % m_max_size;  //m_back + 1为要让出入数据的位置，取模能防止跃出队列位置

​		m_front = (m_front + 1) % m_max_size; //循环队列中，不论进队列还是出队列，尾指针或者头指针都先加1

### 包含的功能：

1、创建一个阻塞队列，利用循环数组实现

2、将异步日志所写的日志内容先存入阻塞队列（生产者）

3、写线程从阻塞队列中取出内容，写入日志。另可利用条件变量的等待时间参数实现等待（消费者）

### 设计总结：

**异步日志**，将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志

**阻塞队列**，将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区

**生产者-消费者模型**，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push消息，消费者线程从缓		冲区中pop消息

___



### log.h头文件涉及函数概要

H：fputs()

>int fputs(const char *str, FILE *stream)函数是标准C库中的一个输出函数，用于将字符串写入到指定的文件流		中。将字符串 str 写入到文件流 stream 中，直到遇到 null 终止符或写入错误。它不会在输出中添加换行		符。如果文件流操作成功，则返回写入的字符数。
>

### 包含的功能：

1、创建一个日志类，私有化其构造函数不让外界创建创建实例

2、创建一个公有的静态方法，在其内部再创建一个生成实例的静态变量

3、函数体内返回该变量的地址，提供给方法调用者获取该实例

4、创建一个获取异步写日志阻塞队列弹出需要处理的任务的方法，并将通过串接受收到的内容，传入到文件地址处

5、创建一个回调函数，等待前公有的静态方法获取调用异步写入日志的方法

6、自定义输出日志的自定义宏

>void write_log(int level, const char *format, ...);	//将输出内容按照标准格式整理
>
>#define LOG_INFO(format, ...) if(条件) {Log::get_instance()->write_log(1, format, ## _VA_ARGS__); 等}

### 设计总结：

**单例模式**，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享

>私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个		公有的静态方法获取该实例。或使用线程安全的静态局部变量实现线程安全懒汉模式

___



### log.cpp 文件涉及函数概要

T：time_t、struct tm、va_list

H：memset()、time() 、localtime()、strrchr()、strcpy()、snprintf()、fopen()、va_start()、vsnprintf()、va_end()、				fflush()、c_str()

>time函数用于获取当前的系统时间（以秒为单位）自1970年1月1日以来的秒数（UNIX时间戳）
>
>localtime函数用于将时间戳转换为本地时间，并返回一个指向 tm结构的指针
>
>snprintf函数将格式化的数据输出到字符串中
>
>vsnprintf函数用于可变参数列表的字符串格式化
>
>c_str 函数返回的是一个指向以 null 结尾的 C 风格字符串的指针，这样就可以在 C 标准库中使用这个字符串。



### 包含的功能：

1、实现日志初始化，判断如果是异步日志则创建一个阻塞队列，同时创建子线程，在其回调函数中处理阻塞队列的日志		输出

2、获取本地时间的拷贝份

3、自定义格式化日志名，根据传入的整个文件名字符串进行分析，若输入的文件名没有/，则直接将时间+文件名作为日志名；	若有/则，将文件名拆分为路径名与日志名

> 需要拆分的情况：
>
>const char *p = strrchr(file_name, '/'); //查找字符最后一次出现的位置，并返回指向该位置的指
>
>strcpy(log_name, p + 1); //指针未移动
>
>strncpy(dir_name, file_name, p - file_name + 1); //p - file_name + 1是文件所在路径文件夹的长度，因为				file_name为数组首地址，指向文件名最后一个/符的 p - file_name + 1 即为路径名

4、将格式化好的日志名作为文件路径，以追加方式打开文件，并将返回的结构体指针赋给成员变量，为后续写入该日志		做准备

5、创建一个写入日志的方法，方法的参数列表为可变参数列表，实现超行、按天分文件的业务逻辑

6、最后将完成的同步日志输入到之前返回的结构体指针指向的的文件；若是异步则将日志加入到阻塞队列等待处理